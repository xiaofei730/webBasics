<?php  

//类是对象的抽象模板，而对象是类的具体实例  对象包含的数据称之为类属性（Property），操作数据的函数称之为类方法（Method）。
/**
 * Class car
 */
class Car
{

	

	const WHEELS = 4; //汽车都是4个轮子
	var $seats; 	  // 座位
	var $doors;		  // 门
	var $engine;	  // 发动机
	private $brand;		  // 品≈牌


	/**
	 * Car constructor.
	 * @param $seats
	 * @param $doors
	 * @param $engine
	 * @param $brand
	 */
	public function __construct($brand, $seats = 5, $doors = 1, $engine = 1)
	{
	    $this->seats = $seats;
	    $this->doors = $doors;
	    $this->engine = $engine;
	    $this->brand = $brand;
	}

	public function getBrand()
	{
		return $this->brand;
	}

	public function setBrand($brand): void
	{
		$this->brand = $brand;
	}

	public function drive()
	{
		echo "1.启动引擎..." . PHP_EOL;
   		echo "2.挂D档..." . PHP_EOL;
    	echo "3.放下手刹..." . PHP_EOL;
    	echo "4.踩油门,出发..." . PHP_EOL;
    	printf("5.%s汽车已出发\n",$this->brand);
	}

	public function close()
	{
		echo "1.踩刹车..." . PHP_EOL;
    	echo "2.挂P档..." . PHP_EOL;
    	echo "3.拉起手刹..." . PHP_EOL;
    	echo "4.关闭引擎..." . PHP_EOL;
    	printf("5.%s汽车已熄火\n",$this->brand);
	}

	

}


if (class_exists('Car')) {
	echo "class Car exists." . PHP_EOL;
} else {
	echo "class Car not exists." . PHP_EOL;
}

//通过 new 关键字进行类的实例化：
$car = new Car("奔驰");

//在类外面访问类常量，需要通过类名 + :: + 常量名的方式：
var_dump(Car::WHEELS);

//对象级别的属性和方法，都是通过箭头符 -> 进行访问的。
$car->seats = 5;
var_dump($car->seats);

$car->setBrand("奔驰");
var_dump($car->getBrand());

$car->drive();
$car->close();

$carTwo = new Car("奔驰");
var_dump($carTwo->getBrand());
var_dump($carTwo->seats);
var_dump($carTwo->doors);
var_dump($carTwo->engine);
$carTwo->drive();
$carTwo->close();


/**
 * 
 */
class Benz extends Car
{
	private $customProp = '自定义属性';
	
	function __construct($seats = 5, $doors = 4, $engine = 1)
	{
		$this->brand = '奔驰';
		parent::__construct($this->brand, $seats, $doors, $engine);
	}

	private function customMethod()
	{
		echo "Call custom prop \$customProp: " . $this->customProp . PHP_EOL;
        echo "This is a custom method in Benz Class" . PHP_EOL;
	}

	//重写父类实现
	public function drive()
	{
		echo $this->getBrand() . '汽车的启动流程:' . PHP_EOL;
		parent::drive(); // TODO: Change the autogenerated stub
	}
}

//public 修饰的属性和方法所有地方可见，不管是当前类、子类还是类之外，protected 修饰的属性和方法在当前类和子类中可见，而 private 修饰的属性和方法仅在当前类可见，
$benz = new Benz();
$benz->drive();
// $benz->customMethod();


// 通过反射调用非 public 方法
$method = new ReflectionMethod(Benz::class, 'customMethod');
$method->setAccessible(true);
$method->invoke($benz);

/**
 * 
 */
class TestCarDrive
{
	
	public function testDrive(Car $car)
	{
		$car->drive();
	}

	public function testBenzDrive(Benz $benz)
	{
		$benz->drive();
	}
}

$bmw = new Car('宝马');
$benz = new Benz();
$test = new TestCarDrive();

//// 测试子类转父类
$test->testDrive($benz);
// 测试父类转子类
// $test->testBenzDrive($bmw);
// 



?>